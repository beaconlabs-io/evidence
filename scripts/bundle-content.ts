import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { EvidenceFrontmatterSchema, EvidenceDeploymentSchema } from "../src/types";
import type { BundledEvidence, EvidenceDeployment } from "../src/types";

const EVIDENCE_DIR = path.join(process.cwd(), "evidence");
const DEPLOYMENTS_DIR = path.join(process.cwd(), "deployments");
const OUTPUT_DIR = path.join(process.cwd(), "src", "content");

interface ValidationError {
  file: string;
  errors: string[];
}

// Ensure output directory exists
function ensureOutputDir(): void {
  try {
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }
  } catch (error) {
    console.error(`Failed to create output directory: ${OUTPUT_DIR}`);
    throw error;
  }
}

// Bundle evidence MDX files with validation
function bundleEvidence(): ValidationError[] {
  const validationErrors: ValidationError[] = [];

  let files: string[];
  try {
    files = fs.readdirSync(EVIDENCE_DIR).filter((f) => f.endsWith(".mdx"));
  } catch (error) {
    console.error(`Failed to read evidence directory: ${EVIDENCE_DIR}`);
    throw error;
  }

  if (files.length === 0) {
    console.warn("Warning: No evidence files found in evidence/ directory");
  }

  const evidence: Record<string, BundledEvidence> = {};

  for (const file of files) {
    const slug = path.basename(file, ".mdx");
    const filePath = path.join(EVIDENCE_DIR, file);

    let raw: string;
    try {
      raw = fs.readFileSync(filePath, "utf-8");
    } catch (error) {
      validationErrors.push({
        file,
        errors: [`Failed to read file: ${error instanceof Error ? error.message : String(error)}`],
      });
      continue;
    }

    let frontmatter: unknown;
    let content: string;
    try {
      const parsed = matter(raw);
      frontmatter = parsed.data;
      content = parsed.content;
    } catch (error) {
      validationErrors.push({
        file,
        errors: [`Failed to parse frontmatter: ${error instanceof Error ? error.message : String(error)}`],
      });
      continue;
    }

    // Validate frontmatter against Zod schema
    const result = EvidenceFrontmatterSchema.safeParse(frontmatter);
    if (!result.success) {
      validationErrors.push({
        file,
        errors: result.error.issues.map(
          (issue) => `${issue.path.join(".")}: ${issue.message}`
        ),
      });
      continue;
    }

    evidence[slug] = {
      frontmatter: result.data,
      content,
      raw,
    };
  }

  const slugs = Object.keys(evidence).sort((a, b) => {
    const idA = parseInt(a, 10);
    const idB = parseInt(b, 10);
    return idA - idB;
  });

  const output = `// Auto-generated by bundle-content.ts - DO NOT EDIT
import type { BundledEvidence } from "../types";

export const evidence: Record<string, BundledEvidence> = ${JSON.stringify(evidence, null, 2)};

export const evidenceSlugs = ${JSON.stringify(slugs)} as const;

export type EvidenceSlug = typeof evidenceSlugs[number];
`;

  try {
    fs.writeFileSync(path.join(OUTPUT_DIR, "evidence.ts"), output);
  } catch (error) {
    console.error(`Failed to write evidence.ts: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }

  console.log(`Bundled ${Object.keys(evidence).length} evidence files`);
  return validationErrors;
}

// Bundle deployment metadata with validation
function bundleDeployments(): ValidationError[] {
  const validationErrors: ValidationError[] = [];

  let files: string[];
  try {
    files = fs.readdirSync(DEPLOYMENTS_DIR).filter((f) => f.endsWith(".json"));
  } catch (error) {
    // Deployments directory may not exist for new projects
    console.warn(`Warning: Could not read deployments directory: ${DEPLOYMENTS_DIR}`);
    files = [];
  }

  const deployments: Record<string, EvidenceDeployment> = {};

  for (const file of files) {
    const slug = path.basename(file, ".json");
    const filePath = path.join(DEPLOYMENTS_DIR, file);

    let rawData: string;
    try {
      rawData = fs.readFileSync(filePath, "utf-8");
    } catch (error) {
      validationErrors.push({
        file,
        errors: [`Failed to read file: ${error instanceof Error ? error.message : String(error)}`],
      });
      continue;
    }

    let data: unknown;
    try {
      data = JSON.parse(rawData);
    } catch (error) {
      validationErrors.push({
        file,
        errors: [`Invalid JSON: ${error instanceof Error ? error.message : String(error)}`],
      });
      continue;
    }

    // Validate deployment against Zod schema
    const result = EvidenceDeploymentSchema.safeParse(data);
    if (!result.success) {
      validationErrors.push({
        file,
        errors: result.error.issues.map(
          (issue) => `${issue.path.join(".")}: ${issue.message}`
        ),
      });
      continue;
    }

    deployments[slug] = result.data;
  }

  const slugs = Object.keys(deployments).sort((a, b) => {
    const idA = parseInt(a, 10);
    const idB = parseInt(b, 10);
    return idA - idB;
  });

  const output = `// Auto-generated by bundle-content.ts - DO NOT EDIT
import type { EvidenceDeployment } from "../types";

export const deployments: Record<string, EvidenceDeployment> = ${JSON.stringify(deployments, null, 2)};

export const deploymentSlugs = ${JSON.stringify(slugs)} as const;

export type DeploymentSlug = typeof deploymentSlugs[number];
`;

  try {
    fs.writeFileSync(path.join(OUTPUT_DIR, "deployments.ts"), output);
  } catch (error) {
    console.error(`Failed to write deployments.ts: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }

  console.log(`Bundled ${Object.keys(deployments).length} deployment files`);
  return validationErrors;
}

// Main execution
function main(): void {
  console.log("Starting content bundling...\n");

  try {
    ensureOutputDir();
  } catch {
    process.exit(1);
  }

  const evidenceErrors = bundleEvidence();
  const deploymentErrors = bundleDeployments();

  const allErrors = [...evidenceErrors, ...deploymentErrors];

  if (allErrors.length > 0) {
    console.error("\n❌ Validation errors found:\n");
    for (const { file, errors } of allErrors) {
      console.error(`  ${file}:`);
      for (const error of errors) {
        console.error(`    - ${error}`);
      }
    }
    console.error(`\n${allErrors.length} file(s) failed validation.`);
    process.exit(1);
  }

  console.log("\n✅ Content bundling complete!");
}

main();
